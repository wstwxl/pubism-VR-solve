<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‰∏âÁª¥ÁßØÊú®ÁºñËæëÂô®</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        :root {
            --bg-primary: #0f0f1a;
            --bg-secondary: #1a1a2e;
            --bg-card: #16213e;
            --bg-hover: #1f3460;
            --accent: #6c63ff;
            --accent-glow: rgba(108, 99, 255, 0.3);
            --text-primary: #e8e8f0;
            --text-secondary: #8888aa;
            --border: #2a2a4a;
            --success: #00c853;
            --warning: #ff9100;
            --danger: #ff3d71
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh
        }

        .header {
            height: 52px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 16px;
            z-index: 100
        }

        .header h1 {
            font-size: 16px;
            font-weight: 600;
            background: linear-gradient(135deg, #6c63ff, #48c6ef);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent
        }

        .header .separator {
            width: 1px;
            height: 24px;
            background: var(--border)
        }

        .mode-tabs {
            display: flex;
            gap: 4px
        }

        .mode-tab {
            padding: 6px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid transparent;
            transition: all .2s
        }

        .mode-tab:hover {
            background: var(--bg-hover);
            color: var(--text-primary)
        }

        .mode-tab.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow)
        }

        .header-right {
            margin-left: auto;
            display: flex;
            gap: 8px
        }

        .btn {
            padding: 7px 14px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            border: 1px solid var(--border);
            background: var(--bg-card);
            color: var(--text-primary);
            transition: all .2s;
            display: inline-flex;
            align-items: center;
            gap: 6px
        }

        .btn:hover {
            background: var(--bg-hover);
            border-color: var(--accent)
        }

        .btn-primary {
            background: var(--accent);
            border-color: var(--accent);
            color: white
        }

        .btn-primary:hover {
            background: #5a52e0;
            box-shadow: 0 0 16px var(--accent-glow)
        }

        .btn-success {
            background: #1b5e20;
            border-color: var(--success);
            color: var(--success)
        }

        .btn-success:hover {
            background: #2e7d32
        }

        .btn-danger {
            background: #4a0e1e;
            border-color: var(--danger);
            color: var(--danger)
        }

        .btn-danger:hover {
            background: #6a1b2a
        }

        .main-layout {
            display: flex;
            height: calc(100vh - 52px)
        }

        .sidebar {
            width: 280px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto
        }

        .sidebar-section {
            padding: 16px;
            border-bottom: 1px solid var(--border)
        }

        .sidebar-section h3 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            color: var(--text-secondary);
            margin-bottom: 12px
        }

        .piece-list {
            display: flex;
            flex-direction: column;
            gap: 6px
        }

        .piece-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            border-radius: 8px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all .2s
        }

        .piece-item:hover {
            background: var(--bg-hover)
        }

        .piece-item.active {
            background: var(--bg-card);
            border-color: var(--accent);
            box-shadow: 0 0 8px var(--accent-glow)
        }

        .piece-color-dot {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            flex-shrink: 0
        }

        .piece-info {
            flex: 1;
            min-width: 0
        }

        .piece-name {
            font-size: 13px;
            font-weight: 500
        }

        .piece-cells {
            font-size: 11px;
            color: var(--text-secondary)
        }

        .piece-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity .2s
        }

        .piece-item:hover .piece-actions {
            opacity: 1
        }

        .piece-action-btn {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: none;
            background: var(--bg-secondary);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center
        }

        .piece-action-btn:hover {
            background: var(--danger);
            color: white
        }

        .add-piece-btn {
            width: 100%;
            padding: 8px;
            border-radius: 8px;
            border: 1px dashed var(--border);
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 13px;
            transition: all .2s;
            margin-top: 8px
        }

        .add-piece-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
            background: rgba(108, 99, 255, 0.05)
        }

        .grid-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px
        }

        .grid-control {
            display: flex;
            flex-direction: column;
            gap: 4px
        }

        .grid-control label {
            font-size: 11px;
            color: var(--text-secondary)
        }

        .grid-control input {
            width: 100%;
            padding: 6px 8px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 13px;
            text-align: center
        }

        .grid-control input:focus {
            outline: none;
            border-color: var(--accent)
        }

        .layer-control {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 12px
        }

        .layer-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--bg-card);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all .2s
        }

        .layer-btn:hover {
            background: var(--accent);
            border-color: var(--accent)
        }

        .layer-display {
            font-size: 14px;
            font-weight: 500;
            flex: 1;
            text-align: center
        }

        .layer-display span {
            color: var(--accent)
        }

        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative
        }

        .canvas-toolbar {
            height: 40px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 12px;
            gap: 8px
        }

        .tool-btn {
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            cursor: pointer;
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid transparent;
            transition: all .15s
        }

        .tool-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary)
        }

        .tool-btn.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent)
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden
        }

        #gridCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%
        }

        .right-panel {
            width: 260px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto
        }

        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 6px
        }

        .color-swatch {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all .15s
        }

        .color-swatch:hover {
            transform: scale(1.15)
        }

        .color-swatch.active {
            border-color: white;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.3)
        }

        .name-input {
            width: 100%;
            padding: 8px 10px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 13px;
            margin-bottom: 8px
        }

        .name-input:focus {
            outline: none;
            border-color: var(--accent)
        }

        .status-bar {
            height: 28px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            font-size: 11px;
            color: var(--text-secondary);
            gap: 16px
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 4px
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--success)
        }

        .preview-3d {
            width: 100%;
            aspect-ratio: 1;
            background: var(--bg-primary);
            border-radius: 8px;
            border: 1px solid var(--border);
            position: relative;
            overflow: hidden;
            cursor: grab
        }

        .preview-3d canvas {
            width: 100%;
            height: 100%
        }

        .preview-3d:active {
            cursor: grabbing
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px
        }

        .stat-card {
            padding: 10px;
            border-radius: 8px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            text-align: center
        }

        .stat-value {
            font-size: 20px;
            font-weight: 700;
            color: var(--accent)
        }

        .stat-label {
            font-size: 10px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: .5px;
            margin-top: 2px
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px)
        }

        .modal {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 24px;
            min-width: 400px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5)
        }

        .modal h2 {
            font-size: 16px;
            margin-bottom: 16px
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 20px
        }

        textarea.json-output {
            width: 100%;
            height: 240px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: var(--bg-primary);
            color: #48c6ef;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            padding: 12px;
            resize: vertical
        }

        textarea.json-output:focus {
            outline: none;
            border-color: var(--accent)
        }

        ::-webkit-scrollbar {
            width: 6px
        }

        ::-webkit-scrollbar-track {
            background: transparent
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444
        }

        .hidden {
            display: none !important
        }

        .solution-canvas-wrap {
            width: 100%;
            aspect-ratio: 1;
            background: var(--bg-primary);
            border-radius: 8px;
            border: 1px solid var(--border);
            cursor: grab;
            overflow: hidden;
            margin-bottom: 16px
        }

        .solution-canvas-wrap:active {
            cursor: grabbing
        }

        .solution-canvas-wrap canvas {
            width: 100%;
            height: 100%
        }

        .solve-log {
            font-family: 'Consolas', monospace;
            font-size: 11px;
            color: var(--text-secondary);
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            max-height: 160px;
            overflow-y: auto;
            white-space: pre-wrap;
            line-height: 1.6
        }

        .solve-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 12px
        }

        .solve-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px
        }

        .solve-legend-dot {
            width: 14px;
            height: 14px;
            border-radius: 3px
        }

        .modal.modal-lg {
            min-width: 520px;
            max-width: 680px
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>üß© ‰∏âÁª¥ÁßØÊú®ÁºñËæëÂô®</h1>
        <div class="separator"></div>
        <div class="mode-tabs">
            <div class="mode-tab active" data-mode="piece" onclick="switchMode('piece')">ÁºñËæëÁßØÊú®</div>
            <div class="mode-tab" data-mode="target" onclick="switchMode('target')">ÁºñËæëÁõÆÊ†á</div>
        </div>
        <div class="header-right">
            <button class="btn" onclick="loadDefaultPuzzle()">üìÇ ËΩΩÂÖ•Á§∫‰æã</button>
            <button class="btn btn-danger" onclick="clearAllData()">üóë Ê∏ÖÁ©∫ÂÖ®ÈÉ®</button>
            <div class="separator" style="width:1px;height:24px;background:var(--border)"></div>
            <button class="btn" onclick="importJSON()">üì• ÂØºÂÖ•</button>
            <button class="btn" onclick="exportJSON()">üì§ ÂØºÂá∫</button>
            <button class="btn btn-primary" onclick="solveInBrowser()" id="solveBtn">üîç ÁΩëÈ°µÊ±ÇËß£</button>
        </div>
    </div>
    <div class="main-layout">
        <div class="sidebar">
            <div class="sidebar-section" id="pieceListSection">
                <h3>ÁßØÊú®ÂàóË°®</h3>
                <div class="piece-list" id="pieceList"></div>
                <button class="add-piece-btn" onclick="addNewPiece()">+ Ê∑ªÂä†Êñ∞ÁßØÊú®</button>
            </div>
            <div class="sidebar-section">
                <h3>ÁºñËæëÁΩëÊ†ºÂ∞∫ÂØ∏</h3>
                <div class="grid-controls">
                    <div class="grid-control"><label>X ÂÆΩ</label><input type="number" id="gridX" value="5" min="1"
                            max="20" onchange="onGridSizeChange()"></div>
                    <div class="grid-control"><label>Y Ê∑±</label><input type="number" id="gridY" value="5" min="1"
                            max="20" onchange="onGridSizeChange()"></div>
                    <div class="grid-control"><label>Z È´ò</label><input type="number" id="gridZ" value="5" min="1"
                            max="20" onchange="onGridSizeChange()"></div>
                </div>
                <div class="layer-control">
                    <button class="layer-btn" onclick="changeLayer(-1)">‚ñº</button>
                    <div class="layer-display">Z Â±Ç: <span id="currentLayerDisplay">1</span> / <span
                            id="totalLayerDisplay">5</span></div>
                    <button class="layer-btn" onclick="changeLayer(1)">‚ñ≤</button>
                </div>
            </div>
            <div class="sidebar-section">
                <h3>ÁªüËÆ°</h3>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="statPieceCount">0</div>
                        <div class="stat-label">ÁßØÊú®Êï∞</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="statPieceCells">0</div>
                        <div class="stat-label">ÁßØÊú®ÊÄªÊ†ºÊï∞</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="statTargetCells">0</div>
                        <div class="stat-label">ÁõÆÊ†áÊ†ºÊï∞</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="statMatch">‚Äî</div>
                        <div class="stat-label">ÊòØÂê¶ÂåπÈÖç</div>
                    </div>
                </div>
            </div>
        </div>
        <div class="canvas-area">
            <div class="canvas-toolbar">
                <button class="tool-btn active" data-tool="draw" onclick="setTool('draw')">üñä ÁîªÁ¨î</button>
                <button class="tool-btn" data-tool="erase" onclick="setTool('erase')">üßπ Ê©°ÁöÆ</button>
                <div class="separator" style="width:1px;height:20px;background:var(--border)"></div>
                <button class="tool-btn" onclick="clearCurrentLayer()">Ê∏ÖÁ©∫Êú¨Â±Ç</button>
                <button class="tool-btn" onclick="clearAllLayers()">Ê∏ÖÁ©∫ÂÖ®ÈÉ®</button>
                <button class="tool-btn" onclick="fillCurrentLayer()">Â°´Êª°Êú¨Â±Ç</button>
                <div style="flex:1"></div>
                <span style="font-size:11px;color:var(--text-secondary)">Â∑¶ÈîÆÁªòÂà∂ / Âè≥ÈîÆÊì¶Èô§ / ÊªöËΩÆÂàáÂ±Ç</span>
            </div>
            <div class="canvas-container"><canvas id="gridCanvas"></canvas></div>
        </div>
        <div class="right-panel">
            <div class="sidebar-section">
                <h3 id="rightPanelTitle">ÂΩìÂâçÁßØÊú®</h3>
                <input type="text" class="name-input" id="currentName" placeholder="ÂêçÁß∞..." onchange="onNameChange()">
            </div>
            <div class="sidebar-section">
                <h3>È¢úËâ≤</h3>
                <div class="color-palette" id="colorPalette"></div>
            </div>
            <div class="sidebar-section">
                <h3>3D È¢ÑËßà <span
                        style="font-size:10px;color:var(--text-secondary);text-transform:none;letter-spacing:0">(ÊãñÊãΩÊóãËΩ¨)</span>
                </h3>
                <div class="preview-3d"><canvas id="preview3dCanvas"></canvas></div>
            </div>
            <div class="sidebar-section" id="coordsSection">
                <h3>ÂùêÊ†áÂàóË°® (ÊòæÁ§∫ÂÄº‰ªé1ÂºÄÂßã)</h3>
                <div id="coordsList"
                    style="font-family:Consolas;font-size:11px;color:var(--text-secondary);max-height:120px;overflow-y:auto;">
                </div>
            </div>
        </div>
    </div>
    <div class="status-bar">
        <div class="status-item">
            <div class="status-dot"></div>Â∞±Áª™
        </div>
        <div class="status-item" id="statusMode">Ê®°Âºè: ÁºñËæëÁßØÊú®</div>
        <div class="status-item" id="statusInfo"></div>
    </div>

    <script src="solver.js"></script>
    <script>
        // ============================================================
        // ÂÖ®Â±ÄÁä∂ÊÄÅ
        // ============================================================
        const STATE = {
            mode: 'piece',
            currentTool: 'draw',
            currentLayer: 0,       // ÂÜÖÈÉ®‰ªç 0-based
            gridSize: { x: 5, y: 5, z: 5 },
            pieces: [],
            activePieceIndex: -1,
            targetCells: new Set(),
            targetColor: '#6c63ff',
            // 3D È¢ÑËßàÊóãËΩ¨ËßíÂ∫¶
            previewRotX: -0.5,
            previewRotY: 0.6,
        };

        const COLORS = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
            '#1abc9c', '#e67e22', '#d35400', '#e84393', '#6c5ce7',
            '#00b894', '#fdcb6e', '#ff7675', '#74b9ff', '#a29bfe',
            '#fab1a0', '#81ecec', '#ffeaa7', '#dfe6e9', '#636e72',
        ];

        let canvas, ctx, previewCanvas, previewCtx;
        let isDrawing = false;
        let cellSize = 36, gridOffsetX = 0, gridOffsetY = 0;
        let prevDragging = false, prevDragX = 0, prevDragY = 0;

        // ============================================================
        // ÂàùÂßãÂåñ
        // ============================================================
        window.addEventListener('load', () => {
            canvas = document.getElementById('gridCanvas');
            ctx = canvas.getContext('2d');
            previewCanvas = document.getElementById('preview3dCanvas');
            previewCtx = previewCanvas.getContext('2d');
            initColorPalette();
            // ËΩΩÂÖ•ÈªòËÆ§Á§∫‰æãË∞úÈ¢ò
            loadDefaultPuzzle();
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('mousedown', onCanvasMouseDown);
            canvas.addEventListener('mousemove', onCanvasMouseMove);
            canvas.addEventListener('mouseup', () => isDrawing = false);
            canvas.addEventListener('mouseleave', () => isDrawing = false);
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            canvas.addEventListener('wheel', onCanvasWheel);
            // 3D È¢ÑËßàÊãñÊãΩÊóãËΩ¨
            previewCanvas.addEventListener('mousedown', e => { prevDragging = true; prevDragX = e.clientX; prevDragY = e.clientY; });
            window.addEventListener('mousemove', e => {
                if (!prevDragging) return;
                STATE.previewRotY += (e.clientX - prevDragX) * 0.01;
                STATE.previewRotX += (e.clientY - prevDragY) * 0.01;
                STATE.previewRotX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, STATE.previewRotX));
                prevDragX = e.clientX; prevDragY = e.clientY;
                render3DPreview();
            });
            window.addEventListener('mouseup', () => prevDragging = false);
            render();
        });

        function resizeCanvas() {
            const c1 = canvas.parentElement;
            canvas.width = c1.clientWidth * devicePixelRatio;
            canvas.height = c1.clientHeight * devicePixelRatio;
            canvas.style.width = c1.clientWidth + 'px';
            canvas.style.height = c1.clientHeight + 'px';
            ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
            const c2 = previewCanvas.parentElement;
            previewCanvas.width = c2.clientWidth * devicePixelRatio;
            previewCanvas.height = c2.clientHeight * devicePixelRatio;
            previewCanvas.style.width = c2.clientWidth + 'px';
            previewCanvas.style.height = c2.clientHeight + 'px';
            previewCtx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
            calculateGridLayout();
            render();
        }

        function calculateGridLayout() {
            const w = canvas.clientWidth, h = canvas.clientHeight;
            cellSize = Math.min(Math.floor((w - 80) / STATE.gridSize.x), Math.floor((h - 80) / STATE.gridSize.y), 50);
            cellSize = Math.max(cellSize, 16);
            gridOffsetX = Math.floor((w - STATE.gridSize.x * cellSize) / 2);
            gridOffsetY = Math.floor((h - STATE.gridSize.y * cellSize) / 2);
        }

        function initColorPalette() {
            const p = document.getElementById('colorPalette');
            p.innerHTML = '';
            COLORS.forEach((c, i) => {
                const s = document.createElement('div');
                s.className = 'color-swatch' + (i === 0 ? ' active' : '');
                s.style.background = c; s.dataset.color = c;
                s.onclick = () => selectColor(c);
                p.appendChild(s);
            });
        }

        function selectColor(color) {
            document.querySelectorAll('.color-swatch').forEach(s => s.classList.toggle('active', s.dataset.color === color));
            if (STATE.mode === 'piece' && STATE.activePieceIndex >= 0) { STATE.pieces[STATE.activePieceIndex].color = color; renderPieceList(); render(); }
            else if (STATE.mode === 'target') { STATE.targetColor = color; render(); }
        }

        function switchMode(mode) {
            STATE.mode = mode;
            document.querySelectorAll('.mode-tab').forEach(t => t.classList.toggle('active', t.dataset.mode === mode));
            document.getElementById('statusMode').textContent = mode === 'piece' ? 'Ê®°Âºè: ÁºñËæëÁßØÊú®' : 'Ê®°Âºè: ÁºñËæëÁõÆÊ†á';
            document.getElementById('rightPanelTitle').textContent = mode === 'piece' ? 'ÂΩìÂâçÁßØÊú®' : 'ÁõÆÊ†áÁªìÊûÑ';
            document.getElementById('pieceListSection').classList.toggle('hidden', mode === 'target');
            if (mode === 'piece' && STATE.activePieceIndex >= 0) document.getElementById('currentName').value = STATE.pieces[STATE.activePieceIndex].name;
            else if (mode === 'target') document.getElementById('currentName').value = 'ÁõÆÊ†áÁªìÊûÑ';
            render();
        }

        // ============================================================
        // ÁßØÊú®ÁÆ°ÁêÜ
        // ============================================================
        function addNewPiece() {
            const idx = STATE.pieces.length;
            STATE.pieces.push({ name: `ÁßØÊú®${idx + 1}`, color: COLORS[idx % COLORS.length], cells: new Set() });
            STATE.activePieceIndex = idx;
            renderPieceList(); selectPiece(idx); updateStats();
        }
        function selectPiece(idx) {
            STATE.activePieceIndex = idx; STATE.mode = 'piece'; switchMode('piece');
            document.getElementById('currentName').value = STATE.pieces[idx].name;
            selectColor(STATE.pieces[idx].color); renderPieceList(); render();
        }
        function deletePiece(idx) {
            STATE.pieces.splice(idx, 1);
            if (STATE.activePieceIndex >= STATE.pieces.length) STATE.activePieceIndex = STATE.pieces.length - 1;
            if (STATE.pieces.length === 0) { addNewPiece(); return; }
            selectPiece(STATE.activePieceIndex); updateStats();
        }
        function renderPieceList() {
            const list = document.getElementById('pieceList'); list.innerHTML = '';
            STATE.pieces.forEach((piece, idx) => {
                const div = document.createElement('div');
                div.className = 'piece-item' + (idx === STATE.activePieceIndex ? ' active' : '');
                div.innerHTML = `<div class="piece-color-dot" style="background:${piece.color}"></div><div class="piece-info"><div class="piece-name">${piece.name}</div><div class="piece-cells">${piece.cells.size} Ê†º</div></div><div class="piece-actions"><button class="piece-action-btn" title="Âà†Èô§">‚úï</button></div>`;
                div.querySelector('.piece-info').onclick = () => selectPiece(idx);
                div.querySelector('.piece-color-dot').onclick = () => selectPiece(idx);
                div.querySelector('.piece-action-btn').onclick = e => { e.stopPropagation(); deletePiece(idx); };
                list.appendChild(div);
            });
        }
        function onNameChange() {
            if (STATE.mode === 'piece' && STATE.activePieceIndex >= 0) { STATE.pieces[STATE.activePieceIndex].name = document.getElementById('currentName').value; renderPieceList(); }
        }

        // ============================================================
        // ÁΩëÊ†ºÂíåÂ±ÇÊéßÂà∂ (ÂÜÖÈÉ® 0-based, ÊòæÁ§∫ 1-based)
        // ============================================================
        function onGridSizeChange() {
            STATE.gridSize.x = parseInt(document.getElementById('gridX').value) || 5;
            STATE.gridSize.y = parseInt(document.getElementById('gridY').value) || 5;
            STATE.gridSize.z = parseInt(document.getElementById('gridZ').value) || 5;
            if (STATE.currentLayer >= STATE.gridSize.z) STATE.currentLayer = STATE.gridSize.z - 1;
            updateLayerDisplay(); calculateGridLayout(); render();
        }
        function changeLayer(delta) {
            STATE.currentLayer = Math.max(0, Math.min(STATE.gridSize.z - 1, STATE.currentLayer + delta));
            updateLayerDisplay(); render();
        }
        function updateLayerDisplay() {
            document.getElementById('currentLayerDisplay').textContent = STATE.currentLayer + 1; // ÊòæÁ§∫‰ªé1ÂºÄÂßã
            document.getElementById('totalLayerDisplay').textContent = STATE.gridSize.z;
        }

        function setTool(tool) { STATE.currentTool = tool; document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.toggle('active', b.dataset.tool === tool)); }
        function getCurrentCells() { return (STATE.mode === 'piece' && STATE.activePieceIndex >= 0) ? STATE.pieces[STATE.activePieceIndex].cells : STATE.targetCells; }

        function clearCurrentLayer() { const cells = getCurrentCells(); const z = STATE.currentLayer; for (const k of [...cells]) { if (parseInt(k.split(',')[2]) === z) cells.delete(k); } render(); updateStats(); }
        function clearAllLayers() { getCurrentCells().clear(); render(); updateStats(); }
        function fillCurrentLayer() { const cells = getCurrentCells(); const z = STATE.currentLayer; for (let x = 0; x < STATE.gridSize.x; x++) for (let y = 0; y < STATE.gridSize.y; y++) cells.add(`${x},${y},${z}`); render(); updateStats(); }

        // ============================================================
        // ÁîªÂ∏É‰∫§‰∫í ‚Äî Y ËΩ¥ÁøªËΩ¨ÔºöÂ±èÂπïÂ∫ïÈÉ®=YÂ∞è(Ëøë), È°∂ÈÉ®=YÂ§ß(Ëøú)
        // ============================================================
        function getGridCell(e) {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left, my = e.clientY - rect.top;
            const gx = Math.floor((mx - gridOffsetX) / cellSize);
            const screenRow = Math.floor((my - gridOffsetY) / cellSize);
            // ÁøªËΩ¨ YÔºöÂ±èÂπïÁ¨¨0Ë°å = YÊúÄÂ§ßÂÄº, Â±èÂπïÊúÄÂêé‰∏ÄË°å = Y=0
            const gy = STATE.gridSize.y - 1 - screenRow;
            if (gx >= 0 && gx < STATE.gridSize.x && gy >= 0 && gy < STATE.gridSize.y) return { x: gx, y: gy, z: STATE.currentLayer };
            return null;
        }

        function onCanvasMouseDown(e) {
            e.preventDefault(); const cell = getGridCell(e); if (!cell) return;
            isDrawing = true; const key = `${cell.x},${cell.y},${cell.z}`; const cells = getCurrentCells();
            if (e.button === 2 || STATE.currentTool === 'erase') cells.delete(key); else cells.add(key);
            render(); updateStats();
        }
        function onCanvasMouseMove(e) {
            if (!isDrawing) { render(); highlightCell(e); return; }
            const cell = getGridCell(e); if (!cell) return;
            const key = `${cell.x},${cell.y},${cell.z}`; const cells = getCurrentCells();
            if (e.buttons === 2 || STATE.currentTool === 'erase') cells.delete(key); else cells.add(key);
            render(); updateStats();
        }
        function onCanvasWheel(e) { e.preventDefault(); changeLayer(e.deltaY > 0 ? -1 : 1); }
        function highlightCell(e) {
            const cell = getGridCell(e); if (!cell) return;
            // ÁøªËΩ¨ÂõûÂ±èÂπïÂùêÊ†á
            const screenRow = STATE.gridSize.y - 1 - cell.y;
            ctx.strokeStyle = 'rgba(108,99,255,0.8)'; ctx.lineWidth = 2;
            ctx.strokeRect(gridOffsetX + cell.x * cellSize + 1, gridOffsetY + screenRow * cellSize + 1, cellSize - 2, cellSize - 2);
        }

        // ============================================================
        // Ê∏≤Êüì 2D ÁΩëÊ†º ‚Äî Y ËΩ¥ÁøªËΩ¨
        // ============================================================
        function render() { renderGrid(); render3DPreview(); updateCoordsList(); }

        function renderGrid() {
            const w = canvas.clientWidth, h = canvas.clientHeight;
            ctx.clearRect(0, 0, w, h);
            const gx = STATE.gridSize.x, gy = STATE.gridSize.y, z = STATE.currentLayer;
            ctx.fillStyle = '#0a0a14'; ctx.fillRect(0, 0, w, h);

            // ÂÖ∂‰ªñÂ±ÇÊäïÂΩ±
            const ghostCells = STATE.mode === 'piece' && STATE.activePieceIndex >= 0 ? STATE.pieces[STATE.activePieceIndex].cells : STATE.targetCells;
            for (const key of ghostCells) {
                const [cx, cy, cz] = key.split(',').map(Number);
                if (cz !== z && cx < gx && cy < gy) {
                    const sr = gy - 1 - cy; // ÁøªËΩ¨Y
                    ctx.fillStyle = 'rgba(100,100,150,0.15)';
                    ctx.fillRect(gridOffsetX + cx * cellSize, gridOffsetY + sr * cellSize, cellSize, cellSize);
                }
            }

            // ÁΩëÊ†ºÁ∫ø
            ctx.strokeStyle = '#1e1e3a'; ctx.lineWidth = 1;
            for (let x = 0; x <= gx; x++) { ctx.beginPath(); ctx.moveTo(gridOffsetX + x * cellSize, gridOffsetY); ctx.lineTo(gridOffsetX + x * cellSize, gridOffsetY + gy * cellSize); ctx.stroke(); }
            for (let y = 0; y <= gy; y++) { ctx.beginPath(); ctx.moveTo(gridOffsetX, gridOffsetY + y * cellSize); ctx.lineTo(gridOffsetX + gx * cellSize, gridOffsetY + y * cellSize); ctx.stroke(); }

            // ÂΩìÂâçÂ±ÇÂ°´ÂÖÖÊ†º
            const color = (STATE.mode === 'piece' && STATE.activePieceIndex >= 0) ? STATE.pieces[STATE.activePieceIndex].color : STATE.targetColor;
            for (const key of getCurrentCells()) {
                const [cx, cy, cz] = key.split(',').map(Number);
                if (cz === z && cx < gx && cy < gy) {
                    const sr = gy - 1 - cy;
                    ctx.fillStyle = color;
                    ctx.fillRect(gridOffsetX + cx * cellSize + 1, gridOffsetY + sr * cellSize + 1, cellSize - 2, cellSize - 2);
                }
            }

            // ÂùêÊ†áÊ†áÊ≥® ‚Äî ‰ªé1ÂºÄÂßã, YËΩ¥ÁøªËΩ¨
            ctx.fillStyle = '#555'; ctx.font = '10px Inter';
            ctx.textAlign = 'center';
            for (let x = 0; x < gx; x++) ctx.fillText(x + 1, gridOffsetX + x * cellSize + cellSize / 2, gridOffsetY - 6);
            ctx.textAlign = 'right';
            for (let row = 0; row < gy; row++) {
                const yVal = gy - row; // È°∂ÈÉ®=YÊúÄÂ§ß, Â∫ïÈÉ®=Y=1
                ctx.fillText(yVal, gridOffsetX - 6, gridOffsetY + row * cellSize + cellSize / 2 + 4);
            }

            // Â±ÇÊ†áÁ≠æ
            ctx.fillStyle = '#8888aa'; ctx.font = '13px Inter'; ctx.textAlign = 'left';
            ctx.fillText(`Z = ${z + 1}`, gridOffsetX, gridOffsetY + gy * cellSize + 20);
            // ÊñπÂêëÊèêÁ§∫
            ctx.fillStyle = '#555'; ctx.font = '10px Inter'; ctx.textAlign = 'center';
            ctx.fillText('‚Üê X ‚Üí', gridOffsetX + gx * cellSize / 2, gridOffsetY - 18);
            ctx.save(); ctx.translate(gridOffsetX - 20, gridOffsetY + gy * cellSize / 2);
            ctx.rotate(-Math.PI / 2); ctx.fillText('‚Üê Y ‚Üí', 0, 0); ctx.restore();
        }

        // ============================================================
        // 3D È¢ÑËßà ‚Äî ÊîØÊåÅÈº†Ê†áÊãñÊãΩÊóãËΩ¨, ÂÆû‰ΩìÊñπÂùóÊ∏≤Êüì
        // ============================================================
        function render3DPreview() {
            const w = previewCanvas.clientWidth, h = previewCanvas.clientHeight;
            previewCtx.clearRect(0, 0, w, h);
            previewCtx.fillStyle = '#0a0a14'; previewCtx.fillRect(0, 0, w, h);
            const cells = getCurrentCells();
            if (cells.size === 0) return;
            const color = (STATE.mode === 'piece' && STATE.activePieceIndex >= 0) ? STATE.pieces[STATE.activePieceIndex].color : STATE.targetColor;

            const maxDim = Math.max(STATE.gridSize.x, STATE.gridSize.y, STATE.gridSize.z);
            const scale = Math.min(w, h) / (maxDim * 2.2);
            const cx = STATE.gridSize.x / 2, cy = STATE.gridSize.y / 2, cz = STATE.gridSize.z / 2;
            const rotX = STATE.previewRotX, rotY = STATE.previewRotY;

            // 3D‚Üí2D ÊäïÂΩ±ÔºàÁªï‰∏≠ÂøÉÊóãËΩ¨Ôºâ
            function project(x, y, z) {
                let dx = x - cx, dy = y - cy, dz = z - cz;
                // Áªï Y ËΩ¥ÊóãËΩ¨
                let nx = dx * Math.cos(rotY) + dz * Math.sin(rotY);
                let nz = -dx * Math.sin(rotY) + dz * Math.cos(rotY);
                dx = nx; dz = nz;
                // Áªï X ËΩ¥ÊóãËΩ¨
                let ny = dy * Math.cos(rotX) - dz * Math.sin(rotX);
                nz = dy * Math.sin(rotX) + dz * Math.cos(rotX);
                dy = ny; dz = nz;
                return { x: dx * scale + w / 2, y: -dy * scale + h / 2, z: dz };
            }

            // Ê£ÄÊü•Êüê‰∏™‰ΩçÁΩÆÊòØÂê¶ÊúâÊñπÂùó
            const cellSet = new Set(cells);
            function hasCell(x, y, z) { return cellSet.has(`${x},${y},${z}`); }

            // Êî∂ÈõÜÊâÄÊúâÂèØËßÅÁöÑÈù¢
            const faces = [];
            for (const key of cells) {
                const [bx, by, bz] = key.split(',').map(Number);
                // 6‰∏™Èù¢ÔºåÂè™ÁªòÂà∂Êö¥Èú≤Âú®Â§ñÁöÑÈù¢ÔºàÁõ∏ÈÇªÊó†ÊñπÂùóÔºâ
                const dirs = [
                    { dx: 0, dy: 0, dz: 1, verts: [[0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]], shade: 1.0 },   // È°∂ +Z
                    { dx: 0, dy: 0, dz: -1, verts: [[0, 0, 0], [0, 1, 0], [1, 1, 0], [1, 0, 0]], shade: 0.5 },  // Â∫ï -Z
                    { dx: 0, dy: 1, dz: 0, verts: [[0, 1, 0], [0, 1, 1], [1, 1, 1], [1, 1, 0]], shade: 0.7 },   // Âêé +Y
                    { dx: 0, dy: -1, dz: 0, verts: [[0, 0, 0], [1, 0, 0], [1, 0, 1], [0, 0, 1]], shade: 0.8 },  // Ââç -Y
                    { dx: 1, dy: 0, dz: 0, verts: [[1, 0, 0], [1, 1, 0], [1, 1, 1], [1, 0, 1]], shade: 0.65 },  // Âè≥ +X
                    { dx: -1, dy: 0, dz: 0, verts: [[0, 0, 0], [0, 0, 1], [0, 1, 1], [0, 1, 0]], shade: 0.75 }, // Â∑¶ -X
                ];
                for (const d of dirs) {
                    if (!hasCell(bx + d.dx, by + d.dy, bz + d.dz)) {
                        const pts = d.verts.map(v => project(bx + v[0], by + v[1], bz + v[2]));
                        const avgZ = pts.reduce((s, p) => s + p.z, 0) / 4;
                        faces.push({ pts, avgZ, shade: d.shade });
                    }
                }
            }

            // ÁîªÂÆ∂ÁÆóÊ≥ïÊéíÂ∫èÔºöËøúÁöÑÂÖàÁîª
            faces.sort((a, b) => a.avgZ - b.avgZ);

            const rgb = hexToRgb(color);
            for (const face of faces) {
                const s = face.shade;
                previewCtx.fillStyle = `rgb(${Math.round(rgb.r * s)},${Math.round(rgb.g * s)},${Math.round(rgb.b * s)})`;
                previewCtx.strokeStyle = '#222'; previewCtx.lineWidth = 0.8;
                previewCtx.beginPath();
                previewCtx.moveTo(face.pts[0].x, face.pts[0].y);
                for (let i = 1; i < face.pts.length; i++) previewCtx.lineTo(face.pts[i].x, face.pts[i].y);
                previewCtx.closePath(); previewCtx.fill(); previewCtx.stroke();
            }
        }

        function hexToRgb(hex) {
            const n = parseInt(hex.replace('#', ''), 16);
            return { r: (n >> 16) & 0xFF, g: (n >> 8) & 0xFF, b: n & 0xFF };
        }

        // ============================================================
        // ÂùêÊ†áÂàóË°®‰∏éÁªüËÆ° ‚Äî ÊòæÁ§∫ÂÄº‰ªé1ÂºÄÂßã
        // ============================================================
        function updateCoordsList() {
            const cells = getCurrentCells();
            const d = document.getElementById('coordsList');
            if (cells.size === 0) { d.textContent = '(Á©∫)'; return; }
            const sorted = [...cells].sort().map(k => {
                const [x, y, z] = k.split(',').map(Number);
                return `(${x + 1},${y + 1},${z + 1})`;
            });
            d.textContent = sorted.join(', ');
        }

        function updateStats() {
            const pc = STATE.pieces.reduce((s, p) => s + p.cells.size, 0);
            document.getElementById('statPieceCount').textContent = STATE.pieces.length;
            document.getElementById('statPieceCells').textContent = pc;
            document.getElementById('statTargetCells').textContent = STATE.targetCells.size;
            const el = document.getElementById('statMatch');
            if (STATE.targetCells.size === 0) { el.textContent = '‚Äî'; el.style.color = ''; }
            else if (pc === STATE.targetCells.size) { el.textContent = '‚úì'; el.style.color = 'var(--success)'; }
            else { el.textContent = '‚úó'; el.style.color = 'var(--danger)'; }
        }

        // ============================================================
        // ÂØºÂÖ•/ÂØºÂá∫ JSON
        // ============================================================
        function buildJSONData() {
            return {
                pieces: STATE.pieces.map(p => ({ name: p.name, color: p.color, cells: [...p.cells].map(k => k.split(',').map(Number)) })),
                target: { cells: [...STATE.targetCells].map(k => k.split(',').map(Number)) }
            };
        }

        function exportJSON() {
            const json = JSON.stringify(buildJSONData(), null, 2);
            const ov = document.createElement('div'); ov.className = 'modal-overlay';
            ov.innerHTML = `<div class="modal"><h2>üì§ ÂØºÂá∫ JSON</h2><textarea class="json-output" readonly>${json}</textarea><div class="modal-actions"><button class="btn" onclick="this.closest('.modal-overlay').remove()">ÂÖ≥Èó≠</button><button class="btn" onclick="downloadJSON()">üíæ ‰∏ãËΩΩÊñá‰ª∂</button><button class="btn btn-primary" onclick="copyJSON()">üìã Â§çÂà∂</button></div></div>`;
            document.body.appendChild(ov); ov.querySelector('textarea').select();
        }

        function copyJSON() {
            document.querySelector('.modal textarea').select(); document.execCommand('copy');
            const b = document.querySelector('.modal .btn-primary'); b.textContent = '‚úì Â∑≤Â§çÂà∂'; setTimeout(() => b.textContent = 'üìã Â§çÂà∂', 1500);
        }

        function downloadJSON() {
            const json = JSON.stringify(buildJSONData(), null, 2);
            const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([json], { type: 'application/json' })); a.download = 'puzzle_data.json'; a.click();
        }

        function importJSON() {
            const ov = document.createElement('div'); ov.className = 'modal-overlay';
            ov.innerHTML = `<div class="modal"><h2>üì• ÂØºÂÖ• JSON</h2><p style="margin-bottom:12px;color:var(--text-secondary);font-size:13px">Á≤òË¥¥‰πãÂâçÂØºÂá∫ÁöÑ JSON Êï∞ÊçÆÔºö</p><textarea class="json-output" id="importTextarea" placeholder="Âú®Ê≠§Á≤òË¥¥ JSON ..."></textarea><div class="modal-actions"><button class="btn" onclick="this.closest('.modal-overlay').remove()">ÂèñÊ∂à</button><button class="btn btn-primary" onclick="doImport()">Á°ÆËÆ§ÂØºÂÖ•</button></div></div>`;
            document.body.appendChild(ov);
        }

        function doImport() {
            try { loadFromJSON(JSON.parse(document.getElementById('importTextarea').value)); document.querySelector('.modal-overlay').remove(); }
            catch (e) { alert('JSON Ê†ºÂºèÈîôËØØ: ' + e.message); }
        }

        function loadFromJSON(data) {
            STATE.pieces = (data.pieces || []).map(p => ({ name: p.name || 'Êú™ÂëΩÂêç', color: p.color || '#e74c3c', cells: new Set((p.cells || []).map(c => c.join(','))) }));
            STATE.targetCells = new Set((data.target?.cells || []).map(c => c.join(',')));
            const all = [...STATE.pieces.flatMap(p => [...p.cells]), ...STATE.targetCells];
            if (all.length > 0) {
                let mx = 0, my = 0, mz = 0;
                for (const k of all) { const [x, y, z] = k.split(',').map(Number); mx = Math.max(mx, x); my = Math.max(my, y); mz = Math.max(mz, z); }
                STATE.gridSize.x = Math.max(mx + 2, 3); STATE.gridSize.y = Math.max(my + 2, 3); STATE.gridSize.z = Math.max(mz + 2, 3);
                document.getElementById('gridX').value = STATE.gridSize.x;
                document.getElementById('gridY').value = STATE.gridSize.y;
                document.getElementById('gridZ').value = STATE.gridSize.z;
            }
            STATE.currentLayer = 0; STATE.activePieceIndex = STATE.pieces.length > 0 ? 0 : -1;
            if (STATE.pieces.length === 0) addNewPiece();
            updateLayerDisplay(); renderPieceList(); calculateGridLayout(); updateStats(); render();
            if (STATE.activePieceIndex >= 0) selectPiece(0);
        }

        // ============================================================
        // ËΩΩÂÖ•ÈªòËÆ§Á§∫‰æã / Ê∏ÖÁ©∫ÂÖ®ÈÉ®
        // ============================================================
        function loadDefaultPuzzle() {
            loadFromJSON(DEFAULT_PUZZLE);
        }

        function clearAllData() {
            if (!confirm('Á°ÆÂÆöÊ∏ÖÁ©∫ÊâÄÊúâÁßØÊú®ÂíåÁõÆÊ†áÁªìÊûÑÔºü')) return;
            STATE.pieces = [];
            STATE.targetCells = new Set();
            STATE.activePieceIndex = -1;
            STATE.currentLayer = 0;
            STATE.gridSize = { x: 5, y: 5, z: 5 };
            document.getElementById('gridX').value = 5;
            document.getElementById('gridY').value = 5;
            document.getElementById('gridZ').value = 5;
            addNewPiece();
            updateLayerDisplay(); renderPieceList(); calculateGridLayout(); updateStats(); render();
        }

        // ============================================================
        // ÁΩëÈ°µÁ´ØÊ±ÇËß£
        // ============================================================
        function solveInBrowser() {
            const data = buildJSONData();
            const pc = data.pieces.reduce((s, p) => s + p.cells.length, 0);
            if (data.target.cells.length === 0) { alert('ËØ∑ÂÖàÁºñËæëÁõÆÊ†áÁªìÊûÑÔºÅ'); return; }
            if (data.pieces.length === 0 || pc === 0) { alert('ËØ∑ÂÖàÁºñËæëËá≥Â∞ë‰∏ÄÂùóÁßØÊú®ÔºÅ'); return; }

            const btn = document.getElementById('solveBtn');
            btn.textContent = '‚è≥ Ê±ÇËß£‰∏≠...';
            btn.disabled = true;

            // Áî® setTimeout ËÆ© UI ÊúâÊú∫‰ºöÊõ¥Êñ∞
            setTimeout(() => {
                try {
                    const result = solvePuzzle(
                        data.pieces.map(p => ({ name: p.name, color: p.color, cells: p.cells })),
                        data.target.cells
                    );
                    showSolutionModal(result, data.pieces);
                } catch (e) {
                    alert('Ê±ÇËß£Âá∫Èîô: ' + e.message);
                } finally {
                    btn.textContent = 'üîç ÁΩëÈ°µÊ±ÇËß£';
                    btn.disabled = false;
                }
            }, 50);
        }

        // ============================================================
        // Ê±ÇËß£ÁªìÊûúÂ±ïÁ§∫ ‚Äî 3D ÂΩ©Ëâ≤ÂèØÊóãËΩ¨ËßÜÂõæ
        // ============================================================
        function showSolutionModal(result, pieceDefs) {
            const ov = document.createElement('div');
            ov.className = 'modal-overlay';
            ov.onclick = e => { if (e.target === ov) ov.remove(); };

            let legendHtml = '';
            let canvasHtml = '';
            if (result.success) {
                // Âõæ‰æã
                legendHtml = '<div class="solve-legend">';
                for (let i = 0; i < pieceDefs.length; i++) {
                    if (result.solution[i]) {
                        legendHtml += `<div class="solve-legend-item"><div class="solve-legend-dot" style="background:${pieceDefs[i].color}"></div>${pieceDefs[i].name}</div>`;
                    }
                }
                legendHtml += '</div>';
                canvasHtml = '<div class="solution-canvas-wrap"><canvas id="solutionCanvas"></canvas></div>';
            }

            ov.innerHTML = `<div class="modal modal-lg">
                <h2>${result.success ? '‚úÖ Ê±ÇËß£ÊàêÂäü!' : '‚ùå Êó†Ëß£'}</h2>
                ${canvasHtml}
                ${legendHtml}
                <div class="solve-log">${result.log.join('\n')}</div>
                <div class="modal-actions">
                    <button class="btn" onclick="this.closest('.modal-overlay').remove()">ÂÖ≥Èó≠</button>
                    ${result.success ? '<button class="btn btn-primary" onclick="downloadSolutionJSON()">üíæ ‰øùÂ≠òÁªìÊûú</button>' : ''}
                </div>
            </div>`;
            document.body.appendChild(ov);

            if (result.success) {
                // ‰øùÂ≠òÂΩìÂâçÁªìÊûú‰æõ‰∏ãËΩΩ
                window._lastSolution = result;
                window._lastPieceDefs = pieceDefs;
                initSolution3DCanvas(result.solution, pieceDefs);
            }
        }

        function downloadSolutionJSON() {
            if (!window._lastSolution) return;
            const out = {};
            for (const [idx, cells] of Object.entries(window._lastSolution.solution)) {
                const name = window._lastPieceDefs[idx]?.name || `P${idx}`;
                out[name] = cells;
            }
            const json = JSON.stringify(out, null, 2);
            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([json], { type: 'application/json' }));
            a.download = 'solution.json'; a.click();
        }

        function initSolution3DCanvas(solution, pieceDefs) {
            const cvs = document.getElementById('solutionCanvas');
            if (!cvs) return;
            const wrap = cvs.parentElement;
            cvs.width = wrap.clientWidth * devicePixelRatio;
            cvs.height = wrap.clientHeight * devicePixelRatio;
            cvs.style.width = wrap.clientWidth + 'px';
            cvs.style.height = wrap.clientHeight + 'px';
            const sCtx = cvs.getContext('2d');
            sCtx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);

            let solRotX = -0.5, solRotY = 0.6;
            let solDragging = false, solDragX = 0, solDragY = 0;

            // Êî∂ÈõÜÊâÄÊúâÊ†ºÂ≠êÁ°ÆÂÆöËæπÁïå
            let allCells = [];
            for (const [idx, cells] of Object.entries(solution)) {
                for (const c of cells) allCells.push(c);
            }
            let maxX = 0, maxY = 0, maxZ = 0;
            for (const [x, y, z] of allCells) { maxX = Math.max(maxX, x + 1); maxY = Math.max(maxY, y + 1); maxZ = Math.max(maxZ, z + 1); }

            function drawSolution() {
                const w = cvs.clientWidth, h = cvs.clientHeight;
                sCtx.clearRect(0, 0, w, h);
                sCtx.fillStyle = '#0a0a14'; sCtx.fillRect(0, 0, w, h);

                const maxDim = Math.max(maxX, maxY, maxZ);
                const scale = Math.min(w, h) / (maxDim * 2.2);
                const cx = maxX / 2, cy = maxY / 2, cz = maxZ / 2;

                function project(x, y, z) {
                    let dx = x - cx, dy = y - cy, dz = z - cz;
                    let nx = dx * Math.cos(solRotY) + dz * Math.sin(solRotY);
                    let nz = -dx * Math.sin(solRotY) + dz * Math.cos(solRotY);
                    dx = nx; dz = nz;
                    let ny = dy * Math.cos(solRotX) - dz * Math.sin(solRotX);
                    nz = dy * Math.sin(solRotX) + dz * Math.cos(solRotX);
                    return { x: dx * scale + w / 2, y: -ny * scale + h / 2, z: nz };
                }

                // ÂÖ®Â±ÄÊ†ºÂ≠êÈõÜÔºàÊ£ÄÊü•ÈÅÆÊå°Ôºâ
                const globalSet = new Set(allCells.map(c => c.join(',')));
                function hasCell(x, y, z) { return globalSet.has(`${x},${y},${z}`); }

                const faces = [];
                const dirs = [
                    { dx: 0, dy: 0, dz: 1, verts: [[0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]], shade: 1.0 },
                    { dx: 0, dy: 0, dz: -1, verts: [[0, 0, 0], [0, 1, 0], [1, 1, 0], [1, 0, 0]], shade: 0.5 },
                    { dx: 0, dy: 1, dz: 0, verts: [[0, 1, 0], [0, 1, 1], [1, 1, 1], [1, 1, 0]], shade: 0.7 },
                    { dx: 0, dy: -1, dz: 0, verts: [[0, 0, 0], [1, 0, 0], [1, 0, 1], [0, 0, 1]], shade: 0.8 },
                    { dx: 1, dy: 0, dz: 0, verts: [[1, 0, 0], [1, 1, 0], [1, 1, 1], [1, 0, 1]], shade: 0.65 },
                    { dx: -1, dy: 0, dz: 0, verts: [[0, 0, 0], [0, 0, 1], [0, 1, 1], [0, 1, 0]], shade: 0.75 },
                ];

                for (const [idx, cells] of Object.entries(solution)) {
                    const color = pieceDefs[idx]?.color || '#888';
                    const rgb = hexToRgb(color);
                    for (const [bx, by, bz] of cells) {
                        for (const d of dirs) {
                            if (!hasCell(bx + d.dx, by + d.dy, bz + d.dz)) {
                                const pts = d.verts.map(v => project(bx + v[0], by + v[1], bz + v[2]));
                                const avgZ = pts.reduce((s, p) => s + p.z, 0) / 4;
                                faces.push({ pts, avgZ, shade: d.shade, rgb });
                            }
                        }
                    }
                }

                faces.sort((a, b) => a.avgZ - b.avgZ);

                for (const face of faces) {
                    const s = face.shade;
                    sCtx.fillStyle = `rgb(${Math.round(face.rgb.r * s)},${Math.round(face.rgb.g * s)},${Math.round(face.rgb.b * s)})`;
                    sCtx.strokeStyle = '#222'; sCtx.lineWidth = 0.8;
                    sCtx.beginPath();
                    sCtx.moveTo(face.pts[0].x, face.pts[0].y);
                    for (let i = 1; i < face.pts.length; i++) sCtx.lineTo(face.pts[i].x, face.pts[i].y);
                    sCtx.closePath(); sCtx.fill(); sCtx.stroke();
                }
            }

            drawSolution();

            // ÊãñÊãΩÊóãËΩ¨
            cvs.addEventListener('mousedown', e => { solDragging = true; solDragX = e.clientX; solDragY = e.clientY; });
            window.addEventListener('mousemove', e => {
                if (!solDragging) return;
                solRotY += (e.clientX - solDragX) * 0.01;
                solRotX += (e.clientY - solDragY) * 0.01;
                solRotX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, solRotX));
                solDragX = e.clientX; solDragY = e.clientY;
                drawSolution();
            });
            window.addEventListener('mouseup', () => solDragging = false);
        }
    </script>
</body>

</html>